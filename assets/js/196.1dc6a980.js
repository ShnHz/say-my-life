(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{793:function(t,s,e){"use strict";e.r(s);var a=e(24),v=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"vite"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[t._v("#")]),t._v(" Vite")]),t._v(" "),e("h4",{attrs:{id:"_1-说一下vite？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-说一下vite？"}},[t._v("#")]),t._v(" 1.说一下Vite？")]),t._v(" "),e("p",[e("code",{staticClass:"default"},[t._v("vite")]),t._v(" 其实也是一个前端工具，它的出现原因呢是因为当我们构建的项目越来越大的时候，需要处理的js也越来越多，那么传统的那些工具呢就会遇到性能瓶颈；通常需要好长时间才能够启动项目/打包项目，这个时候呢 "),e("code",{staticClass:"default"},[t._v("vite")]),t._v(" 也就应运而生，利用了浏览器所支持的一些最新的ES模块，解决以上的一些问题。")]),t._v(" "),e("h5",{attrs:{id:"缓慢的服务器启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓慢的服务器启动"}},[t._v("#")]),t._v(" 缓慢的服务器启动")]),t._v(" "),e("p",[e("code",{staticClass:"default"},[t._v("Vite")]),t._v(" 通过在一开始将应用中的模块区分为 "),e("strong",[t._v("依赖")]),t._v(" 和 "),e("strong",[t._v("源码")]),t._v(" 两类，改进了开发服务器启动时间。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("依赖")]),t._v(" 是大多在开发时不会变动的js，vite会使用esbuild预构建依赖，esbuild使用Go编写，所以会比使用js编写的打包器快上10-100倍")]),t._v(" "),e("li",[e("strong",[t._v("源码")]),t._v(" 通常包含一些不只是js的文件，比如css、jsx、vue等等，时常会被编辑。vite以元素ESM方式提供源码。这其实是让浏览器接管了打包程序的工作：vite只需要在浏览器请求源码的时候提供源码即可。根据情景动态导入代码，即只在当前屏幕内实际运用时才会被处理。")])]),t._v(" "),e("h5",{attrs:{id:"缓慢的更新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓慢的更新"}},[t._v("#")]),t._v(" 缓慢的更新")]),t._v(" "),e("p",[t._v("在 "),e("code",{staticClass:"default"},[t._v("Vite")]),t._v(" 中，"),e("code",{staticClass:"default"},[t._v("HMR（热更新）")]),t._v(" 是在原生 ESM 上执行的。当编辑一个文件时，"),e("code",{staticClass:"default"},[t._v("Vite")]),t._v(" 只需要精确地使已编辑的模块与其最近的 "),e("code",{staticClass:"default"},[t._v("HMR")]),t._v(" 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，"),e("code",{staticClass:"default"},[t._v("HMR")]),t._v(" 始终能保持快速更新。")]),t._v(" "),e("p",[e("code",{staticClass:"default"},[t._v("Vite")]),t._v(" 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。")]),t._v(" "),e("h4",{attrs:{id:"_2-利用了es的什么新规范才使得它能够得到效果？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-利用了es的什么新规范才使得它能够得到效果？"}},[t._v("#")]),t._v(" 2.利用了ES的什么新规范才使得它能够得到效果？")]),t._v(" "),e("p",[e("code",{staticClass:"default"},[t._v("es module")]),t._v("：ES6的模块化规范")]),t._v(" "),e("ul",[e("li",[t._v("默认开启严格模式；")]),t._v(" "),e("li",[t._v("import")]),t._v(" "),e("li",[t._v("export")]),t._v(" "),e("li",[t._v("default export")])]),t._v(" "),e("p",[t._v("因为传统的方式是将所有的路由，代码文件全部打包为"),e("code",{staticClass:"default"},[t._v("bundle")]),t._v("，再传递给浏览器进行启动，"),e("code",{staticClass:"default"},[t._v("vite")]),t._v("呢其实是利用"),e("code",{staticClass:"default"},[t._v("esm")]),t._v("规范直接将各个模块发送给浏览器，没有了打包的这一阶段，所以快很多。")]),t._v(" "),e("p",[t._v("利用这个规范让浏览器自己去加载依赖，也就是把压力丢给了浏览器，从而达到了项目启动速度快的效果。")])])}),[],!1,null,null,null);s.default=v.exports}}]);