(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{682:function(t,v,_){"use strict";_.r(v);var e=_(24),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),_("p",[t._v("堆：就是一棵"),_("b",[t._v("完全二叉树")]),t._v("，它如果满足以下条件，那么它就是一个堆。")]),t._v(" "),_("ul",[_("li",[t._v("1.任意节点大于或小于它的所有子节点（大根堆、小根堆）")]),t._v(" "),_("li",[t._v("2.总是一完全树，即除了最底层，其它层的节点都被元素填满")])]),t._v(" "),_("p",[t._v("堆的操作主要有：")]),t._v(" "),_("ul",[_("li",[_("b",[t._v("大顶堆调整（Max-Heapify）")]),t._v("，将堆的末端子节点做调整，使得子节点永远小于父节点；")]),t._v(" "),_("li",[_("b",[t._v("创建大顶堆（Build-Max-Heap）")]),t._v("，将堆中所有数据调整位置，使其成为大顶堆；")]),t._v(" "),_("li",[_("b",[t._v("堆排序（Heap-Sort）")]),t._v("，移除在堆顶的根节点，并做大顶堆调整的迭代运算。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);