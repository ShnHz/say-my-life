(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{785:function(_,t,v){"use strict";v.r(t);var a=v(24),s=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"http"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[_._v("#")]),_._v(" HTTP")]),_._v(" "),v("h4",{attrs:{id:"_1-http与https的区别？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-http与https的区别？"}},[_._v("#")]),_._v(" 1.http与https的区别？")]),_._v(" "),v("ul",[v("li",[v("b",[_._v("HTTPS协议需要CA证书")]),_._v("，费用较高；而HTTP协议不需要；")]),_._v(" "),v("li",[_._v("HTTP协议是超文本传输协议，信息是明文传输的，"),v("b",[_._v("HTTPS则是具有安全性的SSL加密传输协议")]),_._v("；")]),_._v(" "),v("li",[_._v("使用不同的连接方式，"),v("b",[_._v("端口也不同")]),_._v("，HTTP协议端口是80，HTTPS协议端口是443；")]),_._v(" "),v("li",[_._v("HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，"),v("b",[_._v("HTTPS更加安全")]),_._v("。")])]),_._v(" "),v("p",[_._v("https的证书的作用？")]),_._v(" "),v("p",[_._v("CA证书，验证所打开的网站是不是可信的，验证你所安装的文件是不是遭到篡改")]),_._v(" "),v("h4",{attrs:{id:"_2-http1-1与http2-0的区别？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-http1-1与http2-0的区别？"}},[_._v("#")]),_._v(" 2.http1.1与http2.0的区别？")]),_._v(" "),v("ul",[v("li",[_._v("二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议。")]),_._v(" "),v("li",[_._v('多路复用：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"。')]),_._v(" "),v("li",[_._v("数据流：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。")]),_._v(" "),v("li",[_._v("头信息压缩：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。")]),_._v(" "),v("li",[_._v("服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。")])]),_._v(" "),v("h4",{attrs:{id:"_3-get和post的请求的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-get和post的请求的区别"}},[_._v("#")]),_._v(" 3.GET和POST的请求的区别")]),_._v(" "),v("ul",[v("li",[_._v("应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。")]),_._v(" "),v("li",[_._v("是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。")]),_._v(" "),v("li",[_._v("发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。")]),_._v(" "),v("li",[_._v("安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。")]),_._v(" "),v("li",[_._v("请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。")]),_._v(" "),v("li",[_._v("参数类型： post 的参数传递支持更多的数据类型。")])]),_._v(" "),v("h4",{attrs:{id:"_4-options请求方法及使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-options请求方法及使用场景"}},[_._v("#")]),_._v(" 4.OPTIONS请求方法及使用场景")]),_._v(" "),v("p",[_._v("OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。")]),_._v(" "),v("p",[_._v("OPTIONS方法是用于请求获得由"),v("code",{staticClass:"default"},[_._v("Request-URI")]),_._v("标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。")]),_._v(" "),v("p",[_._v("OPTIONS请求方法的主要用途有两个：")]),_._v(" "),v("ul",[v("li",[_._v("获取服务器支持的所有HTTP请求方法；")]),_._v(" "),v("li",[_._v("用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。")])]),_._v(" "),v("h4",{attrs:{id:"_5-说一下http-3-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-说一下http-3-0"}},[_._v("#")]),_._v(" 5.说一下HTTP 3.0")]),_._v(" "),v("p",[_._v("HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。")]),_._v(" "),v("ul",[v("li",[_._v("流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。")]),_._v(" "),v("li",[_._v("集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。")]),_._v(" "),v("li",[_._v("多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。")]),_._v(" "),v("li",[_._v("快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。")])]),_._v(" "),v("h4",{attrs:{id:"_6-tcp三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-tcp三次握手"}},[_._v("#")]),_._v(" 6.tcp三次握手")]),_._v(" "),v("p",[_._v("三次握手其实是指建立一个TCP连接时，需要客户端和服务端一共发送三个包")]),_._v(" "),v("p",[_._v("其实就是在：确认通信双方（客户端和服务端）的序列号")]),_._v(" "),v("p",[_._v("第一次握手，客户端发送包，服务端收到了；于是服务端得出了结论：客户端的发送能力和服务端的接收能力正常；")]),_._v(" "),v("p",[_._v("第二次握手，服务端发包，客户端收到了: 于是客户端得出结论：客户端的发送、接受能力和服务端的发送接受能力都正常；不过此时的服务端并不知道客户端的接收能力是否正常；")]),_._v(" "),v("p",[_._v("第三次握手，客户端发包，服务端收到了: 这样服务端才能得出结论：双方的发送和接受能力都是正常的；")]),_._v(" "),v("p",[_._v("总结下来，就是双方都把自身的序列号发给对方，看对方能不能接收到。如果「确认可以」，那就可以正常通信。")]),_._v(" "),v("h4",{attrs:{id:"_7-为什么需要三次握手，两次可以吗？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么需要三次握手，两次可以吗？"}},[_._v("#")]),_._v(" 7.为什么需要三次握手，两次可以吗？")]),_._v(" "),v("p",[_._v("如果采用两次握手，那么只要发出确认报文就能建立TCP连接，那么有可能会出现服务端无法确认客户端是否接收能力正常。")]),_._v(" "),v("p",[_._v("而且可能会因为网络的问题导致服务器资源消耗，比如说客户端发送了一个包，由于网络问题一直没到，然后重发，重发的包抵达了服务器，服务器就相应之后开始建立连接，但是过了一会第一个网络延迟的包也到达了服务器，服务器也会回应请求，但是客户端已经与服务器建立过连接了，这会导致服务端一直等待下去，造成资源浪费")]),_._v(" "),v("h4",{attrs:{id:"_8-tcp四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-tcp四次挥手"}},[_._v("#")]),_._v(" 8.tcp四次挥手")]),_._v(" "),v("p",[_._v("第一次挥手：客户端发送包，请求关闭连接，服务端接受到消息")]),_._v(" "),v("p",[_._v("第二次挥手：服务端发送包，回复已经知道你需要关闭连接，客户端收到包，进入等待状态，因为服务端有可能有没有发送完毕的数据")]),_._v(" "),v("p",[_._v("第三次挥手：服务端发送包，确认自己已经没有多余数据传输了，进入等待状态")]),_._v(" "),v("p",[_._v("第四次挥手：客户端发送包，回应已经确认关闭连接，服务端收到包后关闭连接，客户端等待2MSL也关闭连接")]),_._v(" "),v("h4",{attrs:{id:"_9-tcp为什么是四次挥手呢？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-tcp为什么是四次挥手呢？"}},[_._v("#")]),_._v(" 9.tcp为什么是四次挥手呢？")]),_._v(" "),v("p",[_._v("其实比较好理解，就是当客户端想要关闭连接时，这一来一回两次挥手只是表示了服务器知道了客户端想要关闭连接，但是客户端还是有接受能力的，等服务器确认没有数据传过去了之后，也是一来一回挥手表示服务器没有数据传输了，可以关闭连接，这样四次之后就表示了服务器和客户端两边都已经做好了关闭连接的准备。")]),_._v(" "),v("h3",{attrs:{id:"状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[_._v("#")]),_._v(" 状态码")]),_._v(" "),v("h4",{attrs:{id:"_1-http常见的状态码有哪些？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-http常见的状态码有哪些？"}},[_._v("#")]),_._v(" 1.HTTP常见的状态码有哪些？")]),_._v(" "),v("blockquote",[v("p",[_._v("2XX：成功，表示请求已被成功接收，处理")])]),_._v(" "),v("ul",[v("li",[_._v("200 请求成功。")]),_._v(" "),v("li",[_._v("204 请求成功，但是没有内容返回。")]),_._v(" "),v("li",[_._v("206 服务器已经完成部分请求，range。这个可以被用作断点续存。")])]),_._v(" "),v("blockquote",[v("p",[_._v("3XX：重定向")])]),_._v(" "),v("ul",[v("li",[_._v("301 永久重定向，表示请求的资源已经搬到了其他位置。")]),_._v(" "),v("li",[_._v("302 临时重定向，临时搬到了其他位置。")]),_._v(" "),v("li",[_._v("304 客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户端，原来缓冲的文档还可以继续使用。")])]),_._v(" "),v("blockquote",[v("p",[_._v("4XX：客户端错误")])]),_._v(" "),v("ul",[v("li",[_._v("400  Bad Request：客户端请求有语法错误，服务器无法理解。")]),_._v(" "),v("li",[_._v("403 服务端拒绝服务。")]),_._v(" "),v("li",[_._v("404 找不到资源。")])]),_._v(" "),v("blockquote",[v("p",[_._v("5xx：服务器端错误，服务器未能实现合法的请求")])]),_._v(" "),v("ul",[v("li",[_._v("500 未知错误。")]),_._v(" "),v("li",[_._v("503 服务器临时过载了或者维护了，无法返回请求。")])]),_._v(" "),v("h3",{attrs:{id:"跨域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[_._v("#")]),_._v(" 跨域")]),_._v(" "),v("h4",{attrs:{id:"_1-说一说跨域问题，跨域是什么，怎么解决？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-说一说跨域问题，跨域是什么，怎么解决？"}},[_._v("#")]),_._v(" 1.说一说跨域问题，跨域是什么，怎么解决？")]),_._v(" "),v("p",[_._v("浏览器为了安全性考虑，有一个同源策略，所谓同源策略就是同协议、同地址、同端口，如果不同源就是跨域。")]),_._v(" "),v("ul",[v("li",[_._v("json")]),_._v(" "),v("li",[_._v("nginx转发")]),_._v(" "),v("li",[_._v("本地代理")])]),_._v(" "),v("h4",{attrs:{id:"_2-jsonp的原理是什么，为什么可以跨域？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-jsonp的原理是什么，为什么可以跨域？"}},[_._v("#")]),_._v(" 2.jsonp的原理是什么，为什么可以跨域？")]),_._v(" "),v("p",[_._v("jsonp其实就是利用script标签请求接口获取返回值后，执行对应函数。因为script请求是没有跨域问题的。")])])}),[],!1,null,null,null);t.default=s.exports}}]);